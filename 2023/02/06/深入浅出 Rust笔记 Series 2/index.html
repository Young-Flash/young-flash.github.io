

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Flash">
  <meta name="keywords" content="">
  <title>深入浅出 Rust笔记 Series 2 - Blog of Flash</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"young-flash.github.io","root":"/","version":"1.8.6","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":10},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"lazyload":{"enable":true,"onlypost":false,"loading_img":"/img/loading.gif","offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Blog of Flash</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/decorative_pic/rust-lang.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="深入浅出 Rust笔记 Series 2">
              
                深入浅出 Rust笔记 Series 2
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Flash
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-02-06 16:25" pubdate>
        2023年2月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">深入浅出 Rust笔记 Series 2</h1>
            
            <div class="markdown-body">
              <h1 id="系列导航"><a class="markdownIt-Anchor" href="#系列导航"></a> 系列导航</h1>
<ul>
<li><a href="https://young-flash.github.io/2023/01/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%201/">深入浅出 Rust笔记 Series 1</a></li>
<li><a href="https://young-flash.github.io/2023/02/06/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%202/">深入浅出 Rust笔记 Series 2</a></li>
<li><a href="https://young-flash.github.io/2023/03/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%203/">深入浅出 Rust笔记 Series 3</a></li>
<li><a href="https://young-flash.github.io/2023/03/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%204/">深入浅出 Rust笔记 Series 4</a></li>
</ul>
<p>这是我在阅读范长春的《深入浅出 Rust》时做的笔记，绝大部分内容源自此书，另有小部分内容源自 <a target="_blank" rel="noopener" href="https://course.rs/about-book.html">Rust 圣经</a>。这两份资料是我入门 Rust 的主要材料。</p>
<h1 id="第二部分-内存安全"><a class="markdownIt-Anchor" href="#第二部分-内存安全"></a> 第二部分 内存安全</h1>
<p>Rust 希望通过语言的机制和编译器的功能，把程序员易犯错、不易检查的问题解决在编译期，避免运行时的内存错误。这一部分主要探讨 Rust 是如何达到内存安全特性的。</p>
<h2 id="chap-10-内存管理基础"><a class="markdownIt-Anchor" href="#chap-10-内存管理基础"></a> chap 10 内存管理基础</h2>
<ul>
<li>
<p>segmentation fault 形成：进程空间中的每个段通过硬件 MMU 映射到真正的物理空间；在这个映射过程中可以给不同的段设置不同的访问权限，比如代码段就是只能读不能写；进程在执行过程中，如果违反了这些权限，CPU 会直接产生一个硬件异常；硬件异常会被操作系统内核处理，一般内核会向对应的进程发送一条信号；如果没有实现自己特殊的信号处理函数，默认情况下，这个进程会直接非正常退出；如果操作系统打开了 core dump 功能，在进程退出的时候操作系统会把它当时的内存状态、寄存器状态以及各种相关信息保存到一个文件中，供用户以后调试使用。</p>
</li>
<li>
<p>非内存安全的情况</p>
<ul>
<li>空指针：解引用空指针是不安全的。这块地址空间一般是受保护的，对空指针解引用在大部分平台上会产生 segfault。</li>
<li>野指针：指的是未初始化的指针。它的值取决于它这个位置以前遗留下来的是什么值。所以它可能指向任意一个地方。对它解引用，可能会造成 segfault，也可能不会，纯粹凭运气。但无论如何，这个行为都不会是预期内的行为，是一定会产生 bug 的。</li>
<li>悬空指针:指的是内存空间在被释放了之后，继续使用。它跟野指针类似，同样会读写已经不属于这个指针的内容。</li>
<li>使用未初始化内存：不只是指针类型，任何一种类型不初始化就直接使用都是危险的，造成的后果完全无法预测。</li>
<li>非法释放：内存分配和释放要配对。如果对同一个指针释放两次，会制造出内存错误。如果指针并不是内存分配器返回的值，对其执行释放操作，也是危险的。</li>
<li>缓冲区溢出：指针访问越界了，结果也是类似于野指针，会读取或者修改临近内存空间的值，造成危险。</li>
<li>执行非法函数指针：如果一个函数指针不是准确地指向一个函数地址，那么调用这个函数指针会导致一段随机数据被当成指令来执行，是非常危险的。</li>
<li>数据竞争：在有并发的场景下，针对同一块内存同时读写，且没有同步措施。</li>
</ul>
</li>
<li>
<p>一些内存错误是不算在“内存安全”范畴内的，比如内存泄漏以及内存耗尽。另外，panic 也不属于内存安全相关的问题。</p>
</li>
<li>
<p>panic 和 core dump 之间有重要区别。panic 是发生不可恢复错误后，程序主动执行的一种错误处理机制；而 core dump 则是程序失控之后，触发了操作系统的保护机制而被动退出的。发生 panic 的时候，此处就是确定性的第一现场，我们可以根据 call stack 信息很快找到事发地点，然后修复。panic 是防止更严重内存安全错误的重要机制。</p>
</li>
</ul>
<p>‍</p>
<h2 id="chap-11-所有权和移动语义"><a class="markdownIt-Anchor" href="#chap-11-所有权和移动语义"></a> chap 11 所有权和移动语义</h2>
<h3 id="111-所有权"><a class="markdownIt-Anchor" href="#111-所有权"></a> 11.1 所有权</h3>
<ul>
<li>
<p>“所有权”代表着以下意义：</p>
<ul>
<li>每个值在 Rust 中都有一个变量来管理它，这个变量就是这个值、这块内存的所有者；</li>
<li>每个值在一个时间点上只有一个管理者；</li>
<li>当变量所在的作用域结束的时候，变量以及它代表的值将会被销毁。</li>
</ul>
</li>
<li>
<p>在 Rust 中不可以做“赋值运算符重载”，若需要“深复制”，必须手工调用 clone 方法。这个 clone 方法来自于 std::clone::Clone 这个 trait。clone 方法里面的行为是可以自定义的。</p>
</li>
</ul>
<h3 id="112-移动语义"><a class="markdownIt-Anchor" href="#112-移动语义"></a> 11.2 移动语义</h3>
<ul>
<li>
<p>一个变量可以把它拥有的值转移给另外一个变量，称为“所有权转移”。<strong>赋值语句、函数调用、函数返回等，都有可能导致所有权转移。</strong></p>
</li>
<li>
<p>Rust 中的变量绑定操作，默认是 move 语义，执行了新的变量绑定后，原来的变量就不能再被使用。</p>
</li>
<li>
<p>“语义”不代表最终的执行效率。“语义”只是规定了什么样的代码是编译器可以接受的，以及它执行后的效果可以用怎样的思维模型去理解。<strong>编译器有权在不改变语义的情况下做任何有利于执行效率的优化。语义和优化是两个阶段的事情。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>() <span class="hljs-punctuation">-&gt;</span> BigObject &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">local</span> = …;<br>    <span class="hljs-keyword">return</span> local;<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">create</span>();<br><br><span class="hljs-comment">// 完全可能被优化为类似如下的效果：</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">create</span>(p: &amp;<span class="hljs-keyword">mut</span> BigObject) &#123;<br>    ptr::<span class="hljs-title function_ invoke__">write</span>(p, …);<br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span>: BigObject = <span class="hljs-title function_ invoke__">uninitialized</span>();<br><span class="hljs-title function_ invoke__">create</span>(&amp;<span class="hljs-keyword">mut</span> v);<br></code></pre></td></tr></table></figure>
<p>编译器可以提前在当前调用栈中把大对象的空间分配好，然后把这个对象的指针传递给子函数，由子函数执行这个变量的初始化。这样就避免了大对象的复制工作，参数传递只是一个指针而已。这么做是完全满足移动语义要求的，而且编译器还有权利做更多类似的优化。</p>
</li>
</ul>
<h3 id="113-复制语义"><a class="markdownIt-Anchor" href="#113-复制语义"></a> 11.3 复制语义</h3>
<ul>
<li>
<p>对于一些简单类型，比如整数、bool，在赋值的时候默认采用复制操作</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> : <span class="hljs-type">isize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = v1;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v1);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Rust 中有一部分“特殊照顾”的类型，其变量绑定操作是 copy 语义。所谓的 copy 语义，是指在执行变量绑定操作的时候，v2 是对 v1 所属数据的一份复制。v1 所管理的这块内存依然存在，并未失效，而 v2 是新开辟了一块内存，它的内容是从 v1 管理的内存中复制而来的。和手动调用 clone 方法效果一样，<code>let v2=v1;</code>​ 等效于 <code>let v2 = v1.clone();</code>​。</p>
</li>
<li>
<p>copy 语义与 move 语义：<strong>这两个操作本身是一样的，都是简单的内存复制，区别在于复制完<br />
以后，原先那个变量的生命周期是否结束。</strong></p>
</li>
<li>
<p>在普通变量绑定、函数传参、模式匹配等场景下，凡是实现了 std::marker::Copy trait 的类型，都会执行 copy 语义。基本类型，比如数字、字符、bool 等，都实现了 Copy trait，因此具备 copy 语义。</p>
</li>
<li>
<p>对于自定义类型，默认是没有实现 Copy trait 的，可以手动添上。Copy 继承了 Clone，要实现 Copy trait 必须同时实现 Clone trait。只要一个类型的所有成员都具有 Clone trait，就可以使用 <code>#[derive(Copy, Clone)]</code> ​来让编译器实现 Clone trait 了。</p>
</li>
</ul>
<h3 id="114-box-类型"><a class="markdownIt-Anchor" href="#114-box-类型"></a> 11.4 Box 类型</h3>
<ul>
<li>Box 类型是 Rust 中一种常用的指针类型。<strong>Box 代表“拥有所有权的指针”</strong>，类似于 C++ 里面的 unique_ptr（严格来说，unique_ptr<T> 更像 Option&lt;Box<T>&gt;）</li>
<li>Box 类型永远执行的是 move 语义，不能是 copy 语义。Rust 中的 copy 语义就是浅复制。对于 Box 这样的类型而言，浅复制必然会造成二次释放问题。</li>
<li>它包裹的值会被强制分配在堆上</li>
<li>​<img src="/img/blog_pic/2023/image-20230118104121-gclzz19.png" srcset="/img/loading.gif" alt="image" /></li>
<li>​由于 <code>Box</code>​ 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 <code>Box</code>​ 相比其它智能指针，功能较为单一，可以在以下场景中使用它：
<ul>
<li>特意的将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝：当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移。</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://course.rs/advance/smart-pointer/box.html#boxleak">Box::leak</a> 使用场景：<strong>需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久</strong></li>
</ul>
<h3 id="115-clone-vs-copy"><a class="markdownIt-Anchor" href="#115-clone-vs-copy"></a> 11.5 Clone VS Copy</h3>
<ul>
<li>
<p>std::marker::Copy：如果一个类型 impl 了 Copy trait，意味着任何时候都可以通过简单的内存复制（在 C 语言里按字节复制 memcpy）实现该类型的复制，并且不会产生任何内存安全问题。一旦一个类型实现了 Copy trait，那么它在变量绑定、函数参数传递、函数返回值传递等场景下，都是 copy 语义，而不再是默认的 move 语义。</p>
<ul>
<li>std::marker 模块里面所有的 trait 都是特殊的 trait。目前稳定的有四个，它们是 Copy、Send、Sized、Sync。<strong>它们的特殊之处在于：它们是跟编译器密切绑定的，impl 这些 trait 对编译器的行为有重要影响。在编译器眼里，它们与其他的 trait 不一样。这几个 trait 内部都没有方法，它们的唯一任务是给类型打一个“标记”，表明它符合某种约定——这些约定会影响编译器的静态检查以及代码生成。</strong></li>
</ul>
</li>
<li>
<p>Copy 的实现条件</p>
<ul>
<li>对于自定义类型，只有所有成员都实现了 Copy trait，这个类型才有资格实现 Copy trait。struct 和 enum 类型不会自动实现 Copy trait，只有当 struct 和 enum 内部的每个元素都是 Copy 类型时，编译器才允许针对此类型实现 Copy trait。而对于元组 tuple 类型，如果它的每一个元素都是 Copy 类型，那么这个 tuple 也是 Copy 类型。</li>
<li>常见的数字类型、bool 类型、共享借用指针&amp;，都是具有 Copy 属性的类型。</li>
<li>Box、Vec、可写借用指针&amp;mut 等类型都是不具备 Copy 属性的类型。</li>
<li><strong>对于数组类型，如果它内部的元素类型是 Copy，那么这个数组也是 Copy 类型。</strong></li>
</ul>
</li>
<li>
<p>std::clone::Clone：clone 方法一般用于“基于语义的复制”操作。所以，它做什么事情，跟具<br />
体类型的作用息息相关。比如，对于 Box 类型，clone 执行的是“深复制”；而对于 Rc 类型，clone 做的事情就是把引用计数值加 1。<strong>对于实现了 copy 的类型，它的 clone 方法应该跟 copy 语义相容，等同于按字节复制。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Clone</span> : <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone_from</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, source: &amp;<span class="hljs-keyword">Self</span>) &#123;<br>        *<span class="hljs-keyword">self</span> = source.<span class="hljs-title function_ invoke__">clone</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有两个关联方法，分别是 clone_from 和 clone，clone_from 是有默认实现的，依赖于 clone 方法的实现。clone 方法没有默认实现，需要手动实现。</p>
<ul>
<li>​<code>#[derive(Clone)]</code>​ 让编译器自动生成那些重复的代码。编译器自动生成的 clone 方法非常机械，就是依次调用每个成员的 clone 方法。</li>
</ul>
</li>
<li>
<p>总结</p>
<ul>
<li>Copy 内部没有方法，Clone 内部有两个方法(clone、clone_from)</li>
<li>Copy trait 是给编译器用的，告诉编译器这个类型默认采用 copy 语义而不是 move 语义。Clone trait 是给程序员用的，必须手动调用 clone 方法它才能发挥作用。</li>
<li>Copy trait 不是想实现就能实现的，它对类型是有要求的，有些类型（Box<T>）不可能 impl Copy。而 Clone trait 则没有什么前提条件，任何类型都可以实现（unsized 类型除外，因为无法使用 unsized 类型作为返回值）。</li>
<li>Copy trait 规定了这个类型在执行变量绑定、函数参数传递、函数返回等场景下的操作方式。即这个类型在这种场景下，必然执行的是“简单内存复制”操作，这是由编译器保证的，程序员无法控制。Clone trait 里面的 clone 方法究竟会执行什么操作，则是取决于程序员自己写的逻辑。一般情况下，clone 方法应该执行一个“深复制”操作，但这不是强制性的</li>
<li>Rust 规定了在 T：Copy 的情况下 Clone trait 代表的含义。即：当某变量 t：T 符合 T：Copy 时，它调用 t.clone() 方法的含义必须等同于“简单内存复制”。也就是说，<code>t.clone()</code>​ 的行为必须等同于 <code>let x = std::ptr::read(&amp;t);</code>​ ，也等同于 <code>let x = t;</code>​ 。</li>
</ul>
</li>
</ul>
<h3 id="析构"><a class="markdownIt-Anchor" href="#析构"></a> 析构</h3>
<ul>
<li>
<p>在 Rust 中编写“析构函数”的办法是 impl std::ops::Drop。Drop trait 的定义如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Drop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>主动析构：用户主动调用析构函数是非法的。需调用标准库中的 std::mem::drop()</p>
<ul>
<li>
<p>std::mem::drop() 实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[inline]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>&lt;T&gt;(_x: T) &#123; &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>drop 函数不需要任何的函数体，只需要参数为“值传递”即可。将对象的所有权移入函数中，什么都不用做，编译器就会自动释放掉这个对象了。</li>
<li>因为这个 drop 函数的关键在于使用 move 语义把参数传进来，使得变量的所有权从调用方移动到 drop 函数体内，参数类型一定要是 T，而不是&amp;T 或者其他引用类型。函数体本身其实根本不重要，重要的是把变量的所有权 move 进入这个函数体中，函数调用结束的时候该变量的生命周期结束，变量的析构函数会自动调用，管理的内存空间也会自然释放。这个过程完全符合前面讲的生命周期、move 语义，无须编译器做特殊处理。</li>
<li>因此，对于 Copy 类型的变量，对它调用  std::mem::drop() 是没有意义的。因为 Copy 类型在函数参数传递的时候执行的是复制语义，原来的那个变量依然存在，传入函数中的只是一个复制品，因此原变量的生命周期不会受到影响。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>变量遮蔽（Shadowing）不会导致变量生命周期提前结束，它不等同于 drop。</p>
</li>
<li>
<p>注意：用下划线来绑定一个变量，那么这个变量会当场执行析构，而不是等到当前语句块结束的时候再执行。下划线是特殊符号，不是普通标识符。</p>
</li>
<li>
<p>std::mem::drop（）函数和 std::ops::Drop::drop（）方法的区别</p>
<ol>
<li>std::mem::drop（）函数是一个独立的函数，不是某个类型的成员方法，它由程序员主动调用，作用是使变量的生命周期提前结束；std::ops::Drop::drop（）方法是一个 trait 中定义的方法，当变量的生命周期结束的时候，编译器会自动调用，手动调用是不允许的。</li>
<li>std::mem::drop<T>（_x：T）的参数类型是 T，采用的是 move 语义；std::ops::Drop::drop（&amp;mut self）的参数类型是&amp;mut Self，采用的是可变借用。在析构函数调用过程中，程序员还有机会读取或者修改此对象的属性。</li>
</ol>
</li>
</ul>
<h2 id="chap-12-借用和生命周期"><a class="markdownIt-Anchor" href="#chap-12-借用和生命周期"></a> chap 12 借用和生命周期</h2>
<ul>
<li>
<p>生命周期简而言之就是引用的有效作用域。生命周期符号使用单引号开头，后面跟一个合法的名字。生命周期标记和泛型类型参数是一样的，都需要先声明后使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(arg: &amp;<span class="hljs-symbol">&#x27;a</span> T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123;<br>    &amp;arg.member<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数 <code>first</code>​ 是一个指向 <code>i32</code>​ 类型的引用，具有生命周期 <code>'a</code>​，该函数还有另一个参数 <code>second</code>​，它也是指向 <code>i32</code>​ 类型的引用，并且同样具有生命周期 <code>'a</code>​。此处生命周期标注仅仅说明，这两个参数 <code>first</code>​ 和 <code>second</code>​ 至少活得和’a 一样久，至于到底活多久或者哪个活得更久都无法得知。</p>
</li>
<li>
<p>借用指针类型都有一个生命周期泛型参数，它们的完整写法应该是&amp;'a T、&amp;'a mut T，只不过在做局部变量的时候，生命周期参数是可以省略的。</p>
</li>
<li>
<p>生命周期之间有重要的包含关系。<strong>如果生命周期’a 比’b 更长或相等，则记为’a: 'b，意思是’a 至少不会比’b 短</strong>。'static 是一个特殊的生命周期，它代表的是这个程序从开始到结束的整个阶段，所以它比其他任何生命周期都长。这意味着，任意一个生命周期’a 都满足’static: 'a。</p>
</li>
<li>
<p>Rust 的引用类型是支持“协变”的。在编译器眼里，生命周期就是一个区间，生命周期参数就是一个普通的泛型参数，它可以被特化为某个具体的生命周期。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">select</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(arg1: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, arg2: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> *arg1 &gt; *arg2 &#123;<br>        arg1<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        arg2<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">selected</span> = <span class="hljs-title function_ invoke__">select</span>(&amp;x, &amp;y);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, selected);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>select 函数引入了一个生命周期标记，两个参数以及返回值都是用的这个生命周期标记。在调用的时候，传递的实参其实是具备不同的生命周期的。x 的生命周期明显大于 y 的生命周期，&amp;x 可存活的范围要大于&amp;y 可存活的范围，将它们的实际生命周期分别记录为’x 和’y。select 函数的形式参数要求的是同样的生命周期，而实际参数是两个不同生命周期的引用，这个类型之所以可以匹配成功，就是因为生命周期的协变特性。编译器可以把&amp;x 和&amp;y 的生命周期都缩小到某个生命周期’a 以内，且满足’x：'a，'y：'a。返回的 selected 变量具备’a 生命周期，也并没有超过’x 和’y 的范围。所以，最终的生命周期检查可以通过。</li>
</ul>
</li>
<li>
<p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol>
<li>每一个引用参数都会获得独自的生命周期例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>​，两个引用参数的有两个生命周期标注:<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>​, 依此类推。</li>
<li>​若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期​，也就是所有返回值的生命周期都等于该输入生命周期例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>​，<code>x</code>​ 参数的生命周期会被自动赋给返回值 <code>&amp;i32</code>​，因此该函数等同于 <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>​</li>
<li>若存在多个输入生命周期，且其中一个是 ​<code>&amp;self</code>​ 或 ​​<code>&amp;mut self</code>​，则 ​<code>&amp;self</code>​​ 的生命周期被赋给所有的输出生命周期拥有 <code>&amp;self</code>​ 形式的参数，说明该函数是一个 <code>方法</code>​，该规则让方法的使用便利度大幅提升。</li>
</ol>
</li>
</ul>
<h2 id="chap-15-内部可变性"><a class="markdownIt-Anchor" href="#chap-15-内部可变性"></a> chap 15 内部可变性</h2>
<ul>
<li>
<p>Rust 的 borrow checker 的核心思想是“共享不可变，可变不共享”。但是只有这个规则是不够的，在某些情况下，我们的确需要在存在共享的情况下可变。为了让这种情况是可控的、安全的，Rust 还设计了一种“内部可变性”（interior mutability）</p>
</li>
<li>
<p>承袭可变性：<strong>Rust 中的 mut 关键字不能在声明类型的时候使用，只能跟变量一起使用。类型本身不能规定自己是否是可变的。一个变量是否是可变的，取决于它的使用环境，而不是它的类型。可变还是不可变取决于变量的使用方式。不能在类型声明的时候指定可变性，比如在 struct 中对某部分成员使用 mut 修饰，这是不合法的。只能在变量声明的时候指定可变性。也不能针对变量的某一部分成员指定可变性，其他部分保持不变。</strong></p>
</li>
<li>
<p>存在 &amp;mut T 就不能存在 &amp;T 的原因：这会引发内存安全问题。比如同时拥有 Vec 的可变引用和不可变引用，通过可变引用向该 Vec 中 push 数据，发生扩容后再去读原来的不可变引用，此时那块内存已经失效（迭代器失效）</p>
</li>
<li>
<p>内部可变性——可以通过共享指针修改它内部的值。虽然粗略一看，Cell 类型似乎违反了 Rust 的“唯一修改权”原则。可以存在多个指向 Cell 类型的不可变引用，同时还能利用不可变引用改变 Cell 内部的值。但实际上，这个类型是完全符合“内存安全”的。再想想，为什么 Rust 要尽力避免 alias 和 mutation 同时存在？因为假如同时有可变指针和不可变指针指向同一块内存，有可能出现通过一个可变指针修改内存的过程中，数据结构处于被破坏状态的情况下，被其他的指针观测到。Cell 类型是不会出现这样的情况的。因为 Cell 类型把数据包裹在内部，用户无法获得指向内部状态的指针，这意味着每次方法调用都是执行的一次完整的数据移动操作。每次方法调用之后，Cell 类型的内部都处于一个正确的状态，不可能观察到数据被破坏掉的状态。多个共享指针指向 Cell 类型的状态如下图所示，Cell 就是一个“壳”，它把数据严严实实地包裹在里面，所有的指针只能指向 Cell，不能直接指向数据。修改数据只能通过 Cell 来完成，用户无法创造一个直接指向数据的指针。</p>
<ul>
<li>​<img src="/img/blog_pic/2023/image-20230122104639-2m2f737.png" srcset="/img/loading.gif" alt="image" />​</li>
</ul>
</li>
<li>
<p>内部可变性的实现是因为 Rust 使用了 <code>unsafe</code>​ 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中 由于 <code>Cell</code>​ 类型针对的是实现了 <code>Copy</code>​ 特征的值类型，因此在实际开发中，<code>Cell</code>​ 使用的并不多，因为时实际要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 <code>RefCell</code>​ 来达成目的。Cell 类型没办法制造出直接指向内部数据的指针，而 RefCell 可以；Cell 只适用于 Copy 类型，用于提供值，而 RefCell 用于提供引用。RefCell 类型放弃了编译阶段的 alias+mutation 原则，但依然会在执行阶段保证 alias+mutation 原则。</p>
</li>
<li>
<table>
<thead>
<tr>
<th>Rust 规则</th>
<th>智能指针带来的额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个数据只有一个所有者</td>
<td>​<code>Rc/Arc</code> ​让一个数据可以拥有多个所有者</td>
</tr>
<tr>
<td>要么多个不可变借用，要么一个可变借用</td>
<td>​<code>RefCell</code> ​实现编译期可变、不可变引用共存</td>
</tr>
<tr>
<td>违背规则导致<strong>编译错误</strong></td>
<td>违背规则导致运行时<code>panic</code>​</td>
</tr>
</tbody>
</table>
<ul>
<li>可以看出，<code>Rc/Arc</code>​ 和 <code>RefCell</code>​ 合在一起，解决了 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如 <code>RefCell</code>​ 实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了 <code>panic</code>​ 异常</li>
</ul>
</li>
<li>
<p>内部可变性小例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messenger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-comment">// --------------------------</span><br><span class="hljs-comment">// 我们的代码中的数据结构和实现</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messenger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">push</span>(msg)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>如上所示，外部库中定义了一个消息发送器特征 <code>Messenger</code>​​，它只有一个发送消息的功能：<code>fn send(&amp;self, msg: String)</code>​​，因为发送消息不需要修改自身，因此原作者在定义时，使用了 <code>&amp;self</code>​​ 的不可变借用，这个无可厚非。</p>
<p>要在自己的代码中使用该特征实现一个异步消息队列，出于性能的考虑，消息先写到本地缓存(内存)中，然后批量发送出去，因此在 <code>send</code>​ 方法中，需要将消息先行插入到本地缓存 <code>msg_cache</code>​ 中。但是问题来了，该 <code>send</code>​ 方法的签名是 <code>&amp;self</code>​，因此上述代码会报错：</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0596]: cannot borrow `<span class="hljs-keyword">self</span>.msg_cache` <span class="hljs-keyword">as</span> mutable, <span class="hljs-keyword">as</span> it is behind a `&amp;` reference<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">11</span>:<span class="hljs-number">9</span><br>   |<br><span class="hljs-number">2</span>  |     <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>   |             ----- help: consider changing that to be a mutable reference: `&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>`<br>...<br><span class="hljs-number">11</span> |         <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">push</span>(msg)<br>   |         ^^^^^^^^^^^^^^^^^^ `<span class="hljs-keyword">self</span>` is a `&amp;` reference, so the data it refers to cannot be borrowed <span class="hljs-keyword">as</span> mutable<br></code></pre></td></tr></table></figure>
<ul>
<li>在报错的同时，编译器大聪明还善意地给出了提示：将 <code>&amp;self</code>​​ 修改为 <code>&amp;mut self</code>​​，但是。。。我们实现的特征是定义在外部库中，因此该签名根本不能修改。值此危急关头， <code>RefCell</code>​​ 闪亮登场：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messenger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messenger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mq</span> = MsgQueue &#123;<br>        msg_cache: RefCell::<span class="hljs-title function_ invoke__">new</span>(Vec::<span class="hljs-title function_ invoke__">new</span>()),<br>    &#125;;<br>    mq.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-string">&quot;hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>这个 MQ 功能很弱，但是并不妨碍我们演示内部可变性的核心用法：通过包裹一层 <code>RefCell</code>​​，成功的让 <code>&amp;self</code>​​ 中的 <code>msg_cache</code>​​ 成为一个可变值，然后实现对其的修改。</li>
</ul>
</li>
<li>
<p>性能上看，<code>RefCell</code>​ 由于是非线程安全的，因此无需保证原子性，性能虽然有一点损耗（需要维护一个借用计数器），但是依然非常好，而 <code>Cell</code>​ 则完全不存在任何额外的性能损耗。</p>
<ul>
<li>RefCell 原理：RefCell 内部有一个“借用计数器”，调用 borrow 方法的时候，计数器里面的“共享引用计数”值就加 1。当这个 borrow 结束的时候，会将这个值自动减 1（如下图所示）。同样，borrow_mut 方法被调用的时候，它就记录一下当前存在“可变引用”。如果“共享引用”和“可变引用”同时出现了，就会报错。</li>
<li>​<img src="/img/blog_pic/2023/image-20230122111220-h8k92j6.png" srcset="/img/loading.gif" alt="image" />​</li>
</ul>
</li>
<li>
<p><code>Cell::get_mut(&amp;mut self)</code>​ 可以获取 &amp;mut T，由此可以改变 Cell 内部包裹的值；这个方法和 <code>Cell::set(&amp;self, , val: T)</code>​ 有何区别？ 回答：区别在于 self 的类型，前者是可变引用，后者是不可变引用。在能获取到可变引用的情况下修改内部的数据是理所当然的，但正是在不可变引用下还能修改体现了内部可变性。</p>
</li>
<li>
<p>Cell 和 RefCell 部分 API</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; Cell&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> T &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set</span>(&amp;<span class="hljs-keyword">self</span>, val: T) &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">swap</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">replace</span>(&amp;<span class="hljs-keyword">self</span>, val: T) <span class="hljs-punctuation">-&gt;</span> T &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into_inner</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> T &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T:<span class="hljs-built_in">Copy</span>&gt; Cell&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> T &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; RefCell&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Ref&lt;T&gt; &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_borrow</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Ref&lt;T&gt;, BorrowError&gt; &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_mut</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> RefMut&lt;T&gt; &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">try_borrow_mut</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;RefMut&lt;T&gt;, BorrowMutError&gt; &#123; &#125;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> T &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="chap-16-解引用智能指针"><a class="markdownIt-Anchor" href="#chap-16-解引用智能指针"></a> chap 16 解引用（智能指针）</h2>
<ul>
<li>
<p>解引用操作可以被自定义。方法是实现标准库中的 std::ops::Deref 或者 std::ops::DerefMut 这两个 trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">DerefMut</span>: Deref &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>::Target;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Rust 提供的“自动解引用”机制，是在某些场景下“隐式地”“自动地”做了一些事情：Rust 编译器做了隐式的 deref 调用，当它找不到这个成员方法的时候，会自动尝试使用 deref 方法后再找该方法，一直循环下去。一般情况下，在函数调用的时候，编译器会帮我们尝试自动解引用。但在某些情况下，编译器不会为我们自动插入自动解引用的代码。</p>
</li>
<li>
<p>自动 deref 的规则是，如果类型 T 可以解引用为 U，即 <code>T：Deref&lt;U&gt;</code>，则&amp;T 可以转为&amp;U。<strong>让智能指针透明。这就是自动 Deref 的意义。</strong></p>
</li>
<li>
<p>std::rc::Rc<T>：Rc 指针及其 clone 出的指针对它指向的内部数据只有读功能，和共享引用&amp;一致，因此，它是安全的。区别在于，共享引用对数据完全没有所有权，不负责内存的释放，Rc 指针会在引用计数值减到 0 的时候释放内存。Rust 里面的 Rc&lt;T&gt;类型类似于 C++ 里面的 shared_ptr&lt;const T&gt;类型，且强制不可为空。</p>
<ul>
<li>Rc 实现了 Clone 和 Drop 这两个 trait。在 clone 方法中，它没有对它内部的数据实行深复制，而是将强引用计数值加 1；在 drop 方法中，也没有直接把内部数据释放掉，而是将强引用计数值减 1，当强引用计数值减到 0 的时候，才会析构掉共享的那块数据。当弱引用计数值也减为 0 的时候，才说明没有任何 Rc/Weak 指针指向这块内存，它占用的内存才会被彻底释放。</li>
<li>内部的引用计数是 Cell<usize> 类型</li>
</ul>
</li>
<li>
<p>std::borrow::Cow：当它只需要对所指向的数据进行只读访问的时候，它就只是一个借用指针；当它需要写数据功能时，它会先分配内存，执行复制操作，再对自己拥有所有权的内存进行写入操作。</p>
</li>
<li>
<p>零开销原则：</p>
<blockquote>
<p>C++ implementations obey the zero-overhead principle：What you don’t use，you don’t pay for. And further：What you do use，you couldn’t hand code any better.        ——Stroustrup</p>
</blockquote>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Rust/">Rust</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/09/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%203/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深入浅出 Rust笔记 Series 3</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/30/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%20Rust%E7%AC%94%E8%AE%B0%20Series%201/">
                        <span class="hidden-mobile">深入浅出 Rust 笔记 Series 1</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
    <div id="giscus" class="giscus"></div>
    <!-- <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"Young-Flash/young-flash.github.io","repo-id":"R_kgDOHN76ng","category":"Announcements","category-id":"DIC_kwDOHN76ns4CXf6t","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"theme":"preferred_color_scheme","lang":"zh-CN","input-position":"bottom"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script> -->

    <script src="https://giscus.app/client.js"
        data-repo="Young-Flash/young-flash.github.io"
        data-repo-id="R_kgDOHN76ng"
        data-category="Announcements"
        data-category-id="DIC_kwDOHN76ns4CXf6t"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
    </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>

              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>








  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
